<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Zip Puzzle Game</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
            rel="stylesheet"
        />
        <style>
            body {
                font-family: "Inter", sans-serif;
                touch-action: none;
            }
            .grid-container {
                display: grid;
                grid-template-columns: repeat(6, 1fr);
                grid-template-rows: repeat(6, 1fr);
                touch-action: none;
                user-select: none;
                position: relative;
            }
            .grid-cell {
                width: 100%;
                height: 100%;
                aspect-ratio: 1 / 1;
                border: 1px solid #e5e7eb; /* gray-500 */
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 1.25rem;
                font-weight: 600;
                position: relative;
                transition: background-color 0.5s ease-in-out;
            }
            .path-middle {
                background-color: #dbeafe; /* blue-100 */
            }
            .grid-cell .number-circle {
                width: 2.25rem; /* w-9 */
                height: 2.25rem; /* h-9 */
                background-color: #1f2937; /* gray-800 */
                color: white;
                border-radius: 9999px; /* rounded-full */
                display: flex;
                justify-content: center;
                align-items: center;
                position: relative; /* enable z-index to work */
                z-index: 30;
                transition: background-color 0.1s ease-in-out;
                font-variant-numeric: tabular-nums;
            }
            .grid-cell .number-circle.is-start,
            .grid-cell .number-circle.is-on-path {
                background-color: #3b82f6; /* blue-500 */
                z-index: 30;
            }
            #path-svg path {
                stroke: #60a5fa; /* blue-400 */
                stroke-width: 36;
                stroke-linecap: round;
                stroke-linejoin: round;
                fill: none;
                opacity: 0.9;
            }
            #path-svg {
                z-index: 20;
            }
            .modal {
                z-index: 50;
            }
            .hint-cell-suggestion {
                animation: hint-pulse-green 1.5s ease-in-out;
            }
            .hint-cell-error {
                animation: hint-pulse-red 1.5s ease-in-out;
            }
            @keyframes hint-pulse-green {
                0% {
                    background: repeating-linear-gradient(
                        45deg,
                        #86efac,
                        #86efac 10px,
                        #bbf7d0 10px,
                        #bbf7d0 20px
                    );
                }
                100% {
                    background: transparent;
                }
            }
            @keyframes hint-pulse-red {
                0% {
                    background: repeating-linear-gradient(
                        45deg,
                        #fca5a5,
                        #fca5a5 10px,
                        #fecaca 10px,
                        #fecaca 20px
                    );
                }
                100% {
                    background: transparent;
                }
            }
        </style>
    </head>
    <body
        class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4"
    >
        <div class="w-full max-w-md mx-auto bg-white rounded-xl shadow-lg p-6">
            <div class="flex justify-between items-center mb-4">
                <h1 class="text-2xl font-bold text-gray-800">Zip Puzzle</h1>
                <div class="flex items-center space-x-4">
                    <button
                        id="hint-btn"
                        class="text-sm bg-yellow-200 text-yellow-800 font-semibold py-1 px-3 rounded-lg hover:bg-yellow-300 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        Hint
                    </button>
                    <button
                        id="clear-btn"
                        class="text-sm bg-gray-200 text-gray-700 font-semibold py-1 px-3 rounded-lg hover:bg-gray-300 transition-colors"
                    >
                        Clear
                    </button>
                    <div class="text-right">
                        <div
                            id="level-display"
                            class="text-lg font-semibold text-blue-600"
                        >
                            Level: 1
                        </div>
                        <div
                            id="timer"
                            class="text-lg font-semibold text-gray-600 tabular-nums"
                        >
                            00:00
                        </div>
                    </div>
                </div>
            </div>

            <div class="relative">
                <div
                    id="grid-container"
                    class="grid-container bg-gray-50 border-2 border-gray-500 rounded-lg cursor-pointer overflow-hidden"
                >
                    <!-- Grid cells will be generated by JavaScript -->
                </div>
                <svg
                    id="path-svg"
                    class="absolute top-0 left-0 w-full h-full pointer-events-none"
                ></svg>
            </div>

            <div class="mt-4 text-center">
                <p class="text-gray-500">
                    Connect all numbers in order to fill the entire grid.
                </p>
            </div>
        </div>

        <!-- Start Screen Modal -->
        <div
            id="start-modal"
            class="modal fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center"
        >
            <div
                class="bg-white rounded-lg shadow-xl p-8 text-center max-w-sm mx-auto"
            >
                <h2 class="text-3xl font-bold text-gray-800 mb-4">
                    Zip Puzzle
                </h2>
                <div class="flex flex-row text-gray-600 justify-between mb-6">
                    <p class="flex flex-col">
                        <span class="text-xs">Games</span>
                        <span
                            class="font-bold text-lg tabular-nums"
                            id="stats-rounds"
                            >0</span
                        >
                    </p>
                    <p class="flex flex-col">
                        <span class="text-xs">Hints</span>
                        <span
                            class="font-bold text-lg tabular-nums"
                            id="stats-hints"
                            >0</span
                        >
                    </p>
                    <p class="flex flex-col">
                        <span class="text-xs">Record</span>
                        <span
                            class="font-bold text-lg tabular-nums"
                            id="stats-fastest"
                            >N/A</span
                        >
                    </p>
                </div>
                <button
                    id="play-btn"
                    class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-transform transform hover:scale-105"
                >
                    Play
                </button>
            </div>
        </div>

        <!-- Completion Modal -->
        <div
            id="completion-modal"
            class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden"
        >
            <div
                class="bg-white rounded-lg shadow-xl p-8 text-center max-w-sm mx-auto"
            >
                <h2 class="text-3xl font-bold text-gray-800 mb-2">
                    Level Complete!
                </h2>
                <p id="completion-time" class="text-lg text-gray-600 mb-6">
                    Your time: 00:00
                </p>
                <div class="flex flex-row text-gray-600 justify-between mb-6">
                    <p class="flex flex-col">
                        <span class="text-xs">Games</span>
                        <span
                            class="font-bold text-lg tabular-nums"
                            id="stats-rounds-end"
                            >0</span
                        >
                    </p>
                    <p class="flex flex-col">
                        <span class="text-xs">Hints</span>
                        <span
                            class="font-bold text-lg tabular-nums"
                            id="stats-hints-end"
                            >0</span
                        >
                    </p>
                    <p class="flex flex-col">
                        <span class="text-xs">Record</span>
                        <span
                            class="font-bold text-lg tabular-nums"
                            id="stats-fastest-end"
                            >N/A</span
                        >
                    </p>
                </div>
                <button
                    id="next-level-btn"
                    class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-transform transform hover:scale-105"
                >
                    Next Level
                </button>
            </div>
        </div>

        <script>
            const gridContainer = document.getElementById("grid-container");
            const timerDisplay = document.getElementById("timer");
            const levelDisplay = document.getElementById("level-display");
            const completionModal = document.getElementById("completion-modal");
            const completionTimeDisplay =
                document.getElementById("completion-time");
            const nextLevelBtn = document.getElementById("next-level-btn");
            const clearBtn = document.getElementById("clear-btn");
            const hintBtn = document.getElementById("hint-btn");
            const svgPathEl = document.getElementById("path-svg");
            const startModal = document.getElementById("start-modal");
            const playBtn = document.getElementById("play-btn");

            const GRID_SIZE = 6;
            let grid = [];
            let playerPath = [];
            let numberedCells = new Map();
            let pathElement = null;

            let level = 1;
            let timerInterval;
            let seconds = 0;
            let isDrawing = false;
            let isGameActive = false;
            let playerStats = {
                roundsPlayed: 0,
                fastestTime: null,
                hintsUsed: 0,
            };

            function loadStats() {
                const stats = localStorage.getItem("zipPuzzleStats");
                if (stats) {
                    playerStats = JSON.parse(stats);
                }
                updateStatsUI();
            }

            function saveStats() {
                localStorage.setItem(
                    "zipPuzzleStats",
                    JSON.stringify(playerStats)
                );
                updateStatsUI();
            }

            function formatTime(timeInSeconds) {
                if (
                    timeInSeconds === null ||
                    typeof timeInSeconds === "undefined"
                )
                    return "N/A";
                const mins = Math.floor(timeInSeconds / 60)
                    .toString()
                    .padStart(2, "0");
                const secs = (timeInSeconds % 60).toString().padStart(2, "0");
                return `${mins}:${secs}`;
            }

            function updateStatsUI() {
                const roundsPlayedEls = [
                    document.getElementById("stats-rounds"),
                    document.getElementById("stats-rounds-end"),
                ];
                const hintsUsedEls = [
                    document.getElementById("stats-hints"),
                    document.getElementById("stats-hints-end"),
                ];
                const fastestTimeEls = [
                    document.getElementById("stats-fastest"),
                    document.getElementById("stats-fastest-end"),
                ];

                roundsPlayedEls.forEach(
                    (el) => (el.textContent = playerStats.roundsPlayed)
                );
                hintsUsedEls.forEach(
                    (el) => (el.textContent = playerStats.hintsUsed)
                );
                fastestTimeEls.forEach(
                    (el) =>
                        (el.textContent = formatTime(playerStats.fastestTime))
                );
            }

            function generatePuzzle() {
                let path;
                while (!path || path.length < GRID_SIZE * GRID_SIZE) {
                    path = [];
                    const visited = Array(GRID_SIZE * GRID_SIZE).fill(false);
                    const startNode = Math.floor(
                        Math.random() * GRID_SIZE * GRID_SIZE
                    );

                    function getNeighbors(n) {
                        const neighbors = [];
                        const row = Math.floor(n / GRID_SIZE);
                        const col = n % GRID_SIZE;
                        if (row > 0) neighbors.push(n - GRID_SIZE);
                        if (row < GRID_SIZE - 1) neighbors.push(n + GRID_SIZE);
                        if (col > 0) neighbors.push(n - 1);
                        if (col < GRID_SIZE - 1) neighbors.push(n + 1);
                        return neighbors.sort(() => Math.random() - 0.5);
                    }

                    function findPath(current) {
                        path.push(current);
                        visited[current] = true;
                        if (path.length === GRID_SIZE * GRID_SIZE) return true;

                        for (const neighbor of getNeighbors(current)) {
                            if (!visited[neighbor] && findPath(neighbor))
                                return true;
                        }
                        path.pop();
                        return false;
                    }
                    findPath(startNode);
                }

                numberedCells.clear();
                const numCount = Math.min(18, 7 + Math.floor(level / 3));
                const pathIndices = new Set();
                pathIndices.add(0);
                pathIndices.add(path.length - 1);

                const remainingNumbers = numCount - 2;
                if (remainingNumbers > 0) {
                    const segmentLength = Math.floor(
                        (path.length - 2) / remainingNumbers
                    );
                    for (let i = 0; i < remainingNumbers; i++) {
                        const start = i * segmentLength + 1;
                        const end = (i + 1) * segmentLength;
                        let indexToAdd;
                        do {
                            indexToAdd =
                                Math.floor(Math.random() * (end - start + 1)) +
                                start;
                        } while (pathIndices.has(indexToAdd));
                        pathIndices.add(indexToAdd);
                    }
                }
                const sortedIndices = Array.from(pathIndices).sort(
                    (a, b) => a - b
                );
                sortedIndices.forEach((pathIndex, i) => {
                    const cellIndex = path[pathIndex];
                    const row = Math.floor(cellIndex / GRID_SIZE);
                    const col = cellIndex % GRID_SIZE;
                    numberedCells.set(`${row}-${col}`, i + 1);
                });
            }

            function renderGrid() {
                gridContainer.innerHTML = "";
                grid = [];
                for (let r = 0; r < GRID_SIZE; r++) {
                    const row = [];
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = document.createElement("div");
                        cell.classList.add("grid-cell");
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        const number = numberedCells.get(`${r}-${c}`);
                        if (number) {
                            const numberCircle = document.createElement("span");
                            numberCircle.classList.add("number-circle");
                            numberCircle.textContent = number;
                            if (number === 1)
                                numberCircle.classList.add("is-start");
                            cell.appendChild(numberCircle);
                        }
                        gridContainer.appendChild(cell);
                        row.push(cell);
                    }
                    grid.push(row);
                }
            }

            function startTimer() {
                stopTimer();
                isGameActive = true;
                seconds = 0;
                timerDisplay.textContent = "00:00";
                timerInterval = setInterval(() => {
                    seconds++;
                    timerDisplay.textContent = formatTime(seconds);
                }, 1000);
            }

            function stopTimer() {
                isGameActive = false;
                clearInterval(timerInterval);
            }

            function handleInteractionStart(e) {
                if (!isGameActive) return;
                const cell = e.target.closest(".grid-cell");
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const cellId = `${row}-${col}`;
                const isStartCell = numberedCells.get(cellId) === 1;
                const isLastCellOfCurrentPath =
                    playerPath.length > 0 &&
                    playerPath[playerPath.length - 1].row === row &&
                    playerPath[playerPath.length - 1].col === col;

                if (isStartCell && playerPath.length === 0) {
                    isDrawing = true;
                    playerPath = [{ row, col }];
                    updatePathUI();
                    return;
                }
                if (isLastCellOfCurrentPath) {
                    isDrawing = true;
                }
            }

            function handleInteractionMove(e) {
                if (!isDrawing) return;
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : null;
                const element = touch
                    ? document.elementFromPoint(touch.clientX, touch.clientY)
                    : e.target;
                const cell = element?.closest(".grid-cell");
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const lastPos = playerPath[playerPath.length - 1];
                const isInPath = playerPath.some(
                    (p) => p.row === row && p.col === col
                );

                if (isInPath) {
                    if (
                        playerPath.length > 1 &&
                        playerPath[playerPath.length - 2].row === row &&
                        playerPath[playerPath.length - 2].col === col
                    ) {
                        playerPath.pop();
                        updatePathUI();
                    }
                    return;
                }
                if (
                    Math.abs(lastPos.row - row) +
                        Math.abs(lastPos.col - col) ===
                    1
                ) {
                    // Check if the last number has already been reached
                    let currentMaxNumber = 0;
                    playerPath.forEach((p) => {
                        const num = numberedCells.get(`${p.row}-${p.col}`);
                        if (num > currentMaxNumber) currentMaxNumber = num;
                    });

                    if (currentMaxNumber === numberedCells.size) {
                        return; // Last number reached, do not extend path
                    }

                    // Check for invalid number connection
                    const targetNumber = numberedCells.get(`${row}-${col}`);
                    if (targetNumber) {
                        if (targetNumber !== currentMaxNumber + 1) {
                            return; // Invalid move, do not connect
                        }
                    }
                    playerPath.push({ row, col });
                    updatePathUI();
                }
            }

            function handleInteractionEnd() {
                if (!isDrawing) return;
                isDrawing = false;
                checkWinCondition();
            }

            function drawSvgPath() {
                if (!pathElement) {
                    pathElement = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "path"
                    );
                    svgPathEl.appendChild(pathElement);
                }
                if (playerPath.length < 2) {
                    pathElement.setAttribute("d", "");
                    return;
                }
                // Use precise positions from getBoundingClientRect to avoid
                // fractional-pixel rounding mismatch with CSS centering.
                const svgRect = svgPathEl.getBoundingClientRect();
                const pathData = playerPath
                    .map((pos, index) => {
                        const command = index === 0 ? "M" : "L";
                        const cell = grid[pos.row][pos.col];
                        const cellRect = cell.getBoundingClientRect();
                        const x =
                            cellRect.left - svgRect.left + cellRect.width / 2;
                        const y =
                            cellRect.top - svgRect.top + cellRect.height / 2;
                        return `${command} ${x} ${y}`;
                    })
                    .join(" ");
                pathElement.setAttribute("d", pathData);
            }

            function updatePathUI() {
                grid.forEach((row) =>
                    row.forEach((cell) => {
                        cell.classList.remove("path-middle");
                        const numberCircle =
                            cell.querySelector(".number-circle");
                        if (
                            numberCircle &&
                            !numberCircle.classList.contains("is-start")
                        ) {
                            numberCircle.classList.remove("is-on-path");
                        }
                    })
                );
                playerPath.forEach((pos) => {
                    const cell = grid[pos.row][pos.col];
                    cell.classList.add("path-middle");
                    const numberCircle = cell.querySelector(".number-circle");
                    if (numberCircle) {
                        if (!numberCircle.classList.contains("is-start"))
                            numberCircle.classList.add("is-on-path");
                    }
                });
                drawSvgPath();
            }

            function checkWinCondition() {
                if (playerPath.length !== GRID_SIZE * GRID_SIZE) return;
                let currentNum = 1;
                for (const pos of playerPath) {
                    const expectedNum = numberedCells.get(
                        `${pos.row}-${pos.col}`
                    );
                    if (expectedNum) {
                        if (expectedNum === currentNum) currentNum++;
                        else return;
                    }
                }
                if (currentNum === numberedCells.size + 1) {
                    stopTimer();
                    completionTimeDisplay.textContent = `Your time: ${timerDisplay.textContent}`;
                    if (
                        playerStats.fastestTime === null ||
                        seconds < playerStats.fastestTime
                    ) {
                        playerStats.fastestTime = seconds;
                    }
                    playerStats.roundsPlayed++;
                    saveStats();
                    completionModal.classList.remove("hidden");
                }
            }

            function clearPath() {
                playerPath = [];
                updatePathUI();
            }

            // --- Hint System ---
            function getNeighborsFromIndex(cellIndex) {
                const r = Math.floor(cellIndex / GRID_SIZE);
                const c = cellIndex % GRID_SIZE;
                const neighbors = [];
                if (r > 0) neighbors.push(cellIndex - GRID_SIZE);
                if (r < GRID_SIZE - 1) neighbors.push(cellIndex + GRID_SIZE);
                if (c > 0) neighbors.push(cellIndex - 1);
                if (c < GRID_SIZE - 1) neighbors.push(cellIndex + 1);
                return neighbors;
            }

            function solveFrom(currentPath) {
                const pathSet = new Set(
                    currentPath.map((p) => p.row * GRID_SIZE + p.col)
                );
                const currentMaxNum = currentPath.reduce(
                    (max, p) =>
                        Math.max(
                            max,
                            numberedCells.get(`${p.row}-${p.col}`) || 0
                        ),
                    0
                );

                function isRegionConnected(visitedSet) {
                    const unvisited = [];
                    for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                        if (!visitedSet.has(i)) unvisited.push(i);
                    }
                    if (unvisited.length <= 1) return true;
                    const queue = [unvisited[0]];
                    const reachable = new Set([unvisited[0]]);
                    let head = 0;
                    while (head < queue.length) {
                        const curr = queue[head++];
                        for (const neighbor of getNeighborsFromIndex(curr)) {
                            if (
                                !visitedSet.has(neighbor) &&
                                !reachable.has(neighbor)
                            ) {
                                reachable.add(neighbor);
                                queue.push(neighbor);
                            }
                        }
                    }
                    return reachable.size === unvisited.length;
                }

                function findSolution(path, nextNum) {
                    if (path.length === GRID_SIZE * GRID_SIZE) return path;

                    // Check if we've reached the last number - if so, we can't continue
                    if (nextNum > numberedCells.size) {
                        return null; // Last number already reached, but grid not full - invalid
                    }

                    const lastPos = path[path.length - 1];
                    const lastIndex = lastPos.row * GRID_SIZE + lastPos.col;

                    for (const neighborIndex of getNeighborsFromIndex(
                        lastIndex
                    ).sort(() => Math.random() - 0.5)) {
                        if (pathSet.has(neighborIndex)) continue;

                        const r = Math.floor(neighborIndex / GRID_SIZE);
                        const c = neighborIndex % GRID_SIZE;
                        const targetNum = numberedCells.get(`${r}-${c}`);
                        let nextNumInSequence = nextNum;

                        if (targetNum) {
                            if (targetNum !== nextNum) continue;
                            nextNumInSequence++;

                            // If this is the last number, ensure we can fill remaining cells
                            if (targetNum === numberedCells.size) {
                                const remainingCells =
                                    GRID_SIZE * GRID_SIZE - path.length - 1;
                                if (remainingCells > 0) {
                                    continue; // Can't place last number here - more cells to fill
                                }
                            }
                        }

                        path.push({ row: r, col: c });
                        pathSet.add(neighborIndex);

                        if (isRegionConnected(pathSet)) {
                            const solution = findSolution(
                                path,
                                nextNumInSequence
                            );
                            if (solution) return solution;
                        }

                        path.pop();
                        pathSet.delete(neighborIndex);
                    }
                    return null;
                }
                return findSolution([...currentPath], currentMaxNum + 1);
            }

            function getHint() {
                if (
                    !isGameActive ||
                    playerPath.length === 0 ||
                    playerPath.length === GRID_SIZE * GRID_SIZE
                )
                    return;
                hintBtn.disabled = true;

                setTimeout(() => {
                    playerStats.hintsUsed++;
                    saveStats();

                    let solution = solveFrom(playerPath);

                    if (solution) {
                        // Player is on a correct path
                        const nextMove = solution[playerPath.length];
                        const hintCell = grid[nextMove.row][nextMove.col];
                        hintCell.classList.add("hint-cell-suggestion");
                        setTimeout(() => {
                            hintCell.classList.remove("hint-cell-suggestion");
                            hintBtn.disabled = false;
                        }, 1500);
                    } else {
                        // Player made a mistake
                        let testPath = [...playerPath];
                        while (testPath.length > 1) {
                            testPath.pop();
                            if (solveFrom(testPath)) {
                                const lastGoodMove =
                                    testPath[testPath.length - 1];
                                const hintCell =
                                    grid[lastGoodMove.row][lastGoodMove.col];
                                hintCell.classList.add("hint-cell-error");
                                setTimeout(() => {
                                    hintCell.classList.remove(
                                        "hint-cell-error"
                                    );
                                    hintBtn.disabled = false;
                                }, 1500);
                                return;
                            }
                        }
                        // Should not happen if start is always valid, but as a fallback:
                        hintBtn.disabled = false;
                    }
                }, 10);
            }

            function startNewLevel() {
                level++;
                levelDisplay.textContent = `Level: ${level}`;
                completionModal.classList.add("hidden");
                clearPath();
                generatePuzzle();
                renderGrid();
                startTimer();
            }

            function startGame() {
                startModal.classList.add("hidden");
                generatePuzzle();
                renderGrid();
                startTimer();
            }

            // Event Listeners
            playBtn.addEventListener("click", startGame);
            gridContainer.addEventListener("mousedown", handleInteractionStart);
            document.addEventListener("mousemove", handleInteractionMove);
            document.addEventListener("mouseup", handleInteractionEnd);
            gridContainer.addEventListener(
                "touchstart",
                handleInteractionStart,
                { passive: true }
            );
            document.addEventListener("touchmove", handleInteractionMove, {
                passive: false,
            });
            document.addEventListener("touchend", handleInteractionEnd);
            nextLevelBtn.addEventListener("click", startNewLevel);
            clearBtn.addEventListener("click", clearPath);
            hintBtn.addEventListener("click", getHint);
            window.addEventListener("resize", drawSvgPath);

            // Initial game setup
            loadStats();
        </script>
    </body>
</html>
